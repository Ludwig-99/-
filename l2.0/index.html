<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Review Sentiment Analyzer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@300;400;500;600;700&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: inherit;
        }

        body {
            background: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 25%, #ffd3b6 50%, #ffaaa5 75%, #ff8b94 100%);
            color: #333;
            min-height: 100vh;
            padding: 48px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 15% 20%, rgba(255, 255, 255, 0.8) 0%, transparent 30%),
                radial-gradient(circle at 85% 30%, rgba(255, 255, 255, 0.6) 0%, transparent 30%),
                radial-gradient(circle at 50% 80%, rgba(255, 255, 255, 0.7) 0%, transparent 40%);
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            width: min(960px, 100%);
            padding: 44px 38px;
            border-radius: 28px;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        h1 {
            text-align: center;
            margin-bottom: 6px;
            font-size: clamp(2.2rem, 4.4vw, 2.8rem);
            font-weight: 700;
            letter-spacing: 1px;
            color: #2c7873;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .description {
            text-align: center;
            color: #555;
            line-height: 1.75;
            font-size: 1.05rem;
            max-width: 640px;
            margin: 0 auto;
        }

        .glass-card {
            position: relative;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 24px;
            padding: 26px 28px;
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(15px);
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .glass-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .api-section {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .api-section h2 {
            font-size: 1.4rem;
            color: #2c7873;
            font-weight: 600;
        }

        .api-input {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        label {
            color: #555;
            font-size: 0.95rem;
            letter-spacing: 0.02em;
        }

        input[type="text"] {
            padding: 14px 16px;
            border: 1px solid rgba(44, 120, 115, 0.3);
            border-radius: 14px;
            font-size: 1rem;
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        input[type="text"]::placeholder {
            color: rgba(85, 85, 85, 0.5);
        }

        input[type="text"]:focus {
            border-color: rgba(44, 120, 115, 0.7);
            outline: none;
            box-shadow: 0 0 0 3px rgba(44, 120, 115, 0.2);
        }

        small {
            color: #777;
        }

        button {
            background: linear-gradient(135deg, #2c7873 0%, #50c9ba 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 14px 28px;
            border-radius: 16px;
            cursor: pointer;
            font-size: 1.05rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            letter-spacing: 0.02em;
            transition: transform 0.25s ease, box-shadow 0.25s ease, filter 0.25s ease;
            box-shadow: 0 8px 20px rgba(44, 120, 115, 0.3);
            text-decoration: none;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(44, 120, 115, 0.4);
            filter: brightness(1.05);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            filter: saturate(0.6);
        }

        button i {
            font-size: 1.1rem;
        }

        .review-section {
            display: flex;
            flex-direction: column;
            gap: 22px;
        }

        .button-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .loading {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 14px;
            padding: 20px 0;
            color: #555;
        }

        .spinner {
            border: 4px solid rgba(44, 120, 115, 0.2);
            border-left: 4px solid #2c7873;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            display: none;
            color: #d9534f;
            padding: 14px 18px;
            border-radius: 14px;
            background: rgba(217, 83, 79, 0.1);
            border: 1px solid rgba(217, 83, 79, 0.3);
        }

        .review-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .review-card h3 {
            font-size: 1.15rem;
            color: #2c7873;
            font-weight: 600;
        }

        .review-text {
            line-height: 1.8;
            font-size: 1rem;
            color: #555;
            background: rgba(255, 255, 255, 0.6);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .sentiment-result {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 18px;
            padding: 22px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.6);
            font-weight: 600;
            font-size: 1.05rem;
            color: #333;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.05);
        }

        .sentiment-result.positive {
            border-color: rgba(92, 184, 92, 0.5);
            box-shadow: 0 8px 20px rgba(92, 184, 92, 0.2);
            background: rgba(92, 184, 92, 0.15);
        }

        .sentiment-result.negative {
            border-color: rgba(217, 83, 79, 0.5);
            box-shadow: 0 8px 20px rgba(217, 83, 79, 0.2);
            background: rgba(217, 83, 79, 0.15);
        }

        .sentiment-result.neutral {
            border-color: rgba(240, 173, 78, 0.5);
            box-shadow: 0 8px 20px rgba(240, 173, 78, 0.2);
            background: rgba(240, 173, 78, 0.15);
        }

        .icon {
            font-size: 26px;
        }

        .instructions {
            font-size: 0.95rem;
            line-height: 1.75;
            color: #555;
        }

        .instructions h3 {
            margin-bottom: 12px;
            color: #2c7873;
            font-size: 1.15rem;
        }

        .instructions ol {
            padding-left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        a {
            color: #2c7873;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        a:hover {
            color: #50c9ba;
        }

        footer {
            text-align: center;
            color: rgba(85, 85, 85, 0.7);
            font-size: 0.9rem;
            margin-top: 12px;
        }

        @media (max-width: 768px) {
            body {
                padding: 32px 16px;
            }

            .container {
                padding: 34px 24px;
                gap: 24px;
            }

            .glass-card {
                padding: 22px;
            }

            .button-row {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }

            .description {
                font-size: 0.95rem;
            }

            .container {
                padding: 28px 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Review Sentiment Analyzer</h1>
        <p class="description">Analyze the sentiment of product reviews using Hugging Face's AI model</p>

        <div class="api-section glass-card">
            <h2>Hugging Face API Setup</h2>
            <div class="api-input">
                <label for="api-token">Enter your Hugging Face API Token:</label>
                <input type="text" id="api-token" placeholder="hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx">
                <p><small>Your token is stored only in your browser and is never sent to our servers.</small></p>
            </div>
        </div>

        <div class="review-section">
            <div class="button-row">
                <button id="analyze-btn"><i class="fas fa-wand-magic-sparkles"></i> Analyze Random Review</button>
                <button id="count-nouns-btn"><i class="fas fa-language"></i> Count Nouns</button>
            </div>

            <div class="loading">
                <div class="spinner"></div>
                <p>Analyzing sentiment...</p>
            </div>

            <div class="error" id="error-message"></div>

            <div class="review-card glass-card">
                <h3>Selected Review:</h3>
                <p class="review-text" id="review-text">Click the button above to analyze a random review</p>
            </div>

            <div class="sentiment-result glass-card" id="sentiment-result">
                <i class="fas fa-question-circle icon"></i>
                <span>Sentiment will appear here</span>
            </div>

            <div class="sentiment-result glass-card" id="noun-result">
                <i class="fas fa-language icon"></i>
                <span>Noun count will appear here</span>
            </div>
        </div>

        <div class="instructions glass-card">
            <h3>How to get a Hugging Face API Token:</h3>
            <ol>
                <li>Go to <a href="https://huggingface.co/" target="_blank">huggingface.co</a> and create a free account</li>
                <li>Navigate to your profile settings and access tokens section</li>
                <li>Generate a new token with read permissions</li>
                <li>Copy the token and paste it in the field above</li>
            </ol>
        </div>
    </div>

    <footer>
        <p>This app uses the distilbert-base-uncased-finetuned-sst-2-english model from Hugging Face</p>
    </footer>

    <script>
        // Global variables
        let reviews = [];
        let apiToken = '';

        // DOM elements
        const analyzeBtn = document.getElementById('analyze-btn');
        const countNounsBtn = document.getElementById('count-nouns-btn');
        const reviewText = document.getElementById('review-text');
        const sentimentResult = document.getElementById('sentiment-result');
        const nounResult = document.getElementById('noun-result');
        const loadingElement = document.querySelector('.loading');
        const errorElement = document.getElementById('error-message');
        const apiTokenInput = document.getElementById('api-token');
        const defaultReviewMessage = reviewText.textContent;
        const defaultNounMessage = nounResult.querySelector('span').textContent;

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Set up event listeners
            analyzeBtn.addEventListener('click', analyzeRandomReview);
            countNounsBtn.addEventListener('click', countNouns);
            apiTokenInput.addEventListener('change', saveApiToken);
            countNounsBtn.disabled = true;

            // Load saved API token if exists
            const savedToken = localStorage.getItem('hfApiToken');
            if (savedToken) {
                apiTokenInput.value = savedToken;
                apiToken = savedToken;
            }

            // Load sample reviews for demonstration
            loadSampleReviews();
        });

        // Load sample reviews for demonstration
        function loadSampleReviews() {
            reviews = [
                "This product is absolutely amazing! It exceeded all my expectations and works perfectly.",
                "I'm very disappointed with this purchase. The quality is poor and it broke after just one week.",
                "It's an okay product. Does what it's supposed to but nothing special.",
                "Fantastic value for money! I would definitely recommend this to my friends and family.",
                "Terrible customer service and the product arrived damaged. Very unhappy with this experience.",
                "The product works as described. It's good for the price but could be better.",
                "I love this so much! It has made my life so much easier and the design is beautiful.",
                "Not worth the money at all. Poor quality materials and doesn't work properly.",
                "This is exactly what I needed. Simple, effective, and affordable.",
                "I had high hopes but this product failed to deliver. It's mediocre at best."
            ];
            console.log('Loaded', reviews.length, 'sample reviews');
        }

        // Save API token to localStorage
        function saveApiToken() {
            apiToken = apiTokenInput.value.trim();
            if (apiToken) {
                localStorage.setItem('hfApiToken', apiToken);
            } else {
                localStorage.removeItem('hfApiToken');
            }
        }

        // Analyze a random review
        function analyzeRandomReview() {
            hideError();

            if (reviews.length === 0) {
                showError('No reviews available. Please try again later.');
                return;
            }
            
            const selectedReview = reviews[Math.floor(Math.random() * reviews.length)];

            // Display the review
            reviewText.textContent = selectedReview;
            updateNounResult('fa-language', defaultNounMessage);
            countNounsBtn.disabled = false;

            // Show loading state
            loadingElement.style.display = 'flex';
            analyzeBtn.disabled = true;
            sentimentResult.innerHTML = '';  // Reset previous result
            sentimentResult.className = 'sentiment-result glass-card';  // Reset classes
            
            // Simulate API call with timeout for demonstration
            setTimeout(() => {
                try {
                    const result = simulateSentimentAnalysis(selectedReview);
                    displaySentiment(result);
                } catch (error) {
                    console.error('Error:', error);
                    showError('Failed to analyze sentiment: ' + error.message);
                } finally {
                    loadingElement.style.display = 'none';
                    analyzeBtn.disabled = false;
                }
            }, 1500);
        }

        // Simulate sentiment analysis for demonstration
        function simulateSentimentAnalysis(text) {
            // Simple simulation based on keywords
            const positiveWords = ['amazing', 'fantastic', 'love', 'excellent', 'perfect', 'great', 'good', 'beautiful', 'exceeded'];
            const negativeWords = ['disappointed', 'terrible', 'poor', 'broken', 'unhappy', 'failed', 'mediocre', 'not worth'];
            
            let positiveCount = 0;
            let negativeCount = 0;
            
            const words = text.toLowerCase().split(/\s+/);
            
            words.forEach(word => {
                if (positiveWords.some(positive => word.includes(positive))) {
                    positiveCount++;
                }
                if (negativeWords.some(negative => word.includes(negative))) {
                    negativeCount++;
                }
            });
            
            // Determine sentiment based on word counts
            if (positiveCount > negativeCount) {
                return [[{label: 'POSITIVE', score: 0.8 + Math.random() * 0.15}]];
            } else if (negativeCount > positiveCount) {
                return [[{label: 'NEGATIVE', score: 0.8 + Math.random() * 0.15}]];
            } else {
                return [[{label: 'NEUTRAL', score: 0.6 + Math.random() * 0.2}]];
            }
        }

        // Display sentiment result
        function displaySentiment(result) {
            // Default to neutral if we can't parse the result
            let sentiment = 'neutral';
            let score = 0.5;
            let label = 'NEUTRAL';
            
            // Parse the API response (format: [[{label: 'POSITIVE', score: 0.99}]])
            if (Array.isArray(result) && result.length > 0 && Array.isArray(result[0]) && result[0].length > 0) {
                const sentimentData = result[0][0];
                label = sentimentData.label?.toUpperCase() || 'NEUTRAL';
                score = sentimentData.score ?? 0.5;
                
                // Determine sentiment
                if (label === 'POSITIVE' && score > 0.5) {
                    sentiment = 'positive';
                } else if (label === 'NEGATIVE' && score > 0.5) {
                    sentiment = 'negative';
                }
            }
            
            // Update UI
            sentimentResult.classList.add(sentiment);
            sentimentResult.innerHTML = `
                <i class="fas ${getSentimentIcon(sentiment)} icon"></i>
                <span>${label} (${(score * 100).toFixed(1)}% confidence)</span>
            `;
        }

        // Get appropriate icon for sentiment
        function getSentimentIcon(sentiment) {
            switch(sentiment) {
                case 'positive':
                    return 'fa-thumbs-up';
                case 'negative':
                    return 'fa-thumbs-down';
                default:
                    return 'fa-question-circle';
            }
        }

        // Show error message
        function showError(message) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // Hide error message
        function hideError() {
            errorElement.style.display = 'none';
        }

        async function countNouns() {
            hideError();
            const text = reviewText.textContent.trim();
            if (!text || text === defaultReviewMessage) {
                showError('Please analyze a review before counting nouns.');
                return;
            }
            countNounsBtn.disabled = true;
            updateNounResult('fa-spinner', 'Counting nouns...', true);
            
            // Simulate API call with timeout for demonstration
            setTimeout(() => {
                try {
                    const tokens = simulatePosAnalysis(text);
                    const summary = summarizeNouns(tokens, text);
                    if (summary.total === 0) {
                        updateNounResult('fa-language', 'No nouns detected');
                    } else {
                        const details = summary.breakdown
                            .slice(0, 5)
                            .map(item => `${item.word} (${item.count})`)
                            .join(', ');
                        const extra = summary.breakdown.length > 5 ? `, +${summary.breakdown.length - 5} more` : '';
                        updateNounResult('fa-language', `${summary.total} nouns detected • ${details}${extra}`);
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showError('Failed to count nouns: ' + error.message);
                    updateNounResult('fa-language', defaultNounMessage);
                } finally {
                    countNounsBtn.disabled = false;
                }
            }, 1000);
        }

        // Simulate POS analysis for demonstration
        function simulatePosAnalysis(text) {
            // Simple simulation that identifies nouns in the text
            const words = text.split(/\s+/);
            const nouns = ['product', 'quality', 'design', 'money', 'value', 'service', 'experience', 'life', 'materials', 'friends', 'family', 'expectations', 'week', 'purchase'];
            
            return words.map((word, index) => {
                const cleanWord = word.toLowerCase().replace(/[.,!?]/g, '');
                if (nouns.includes(cleanWord) || Math.random() > 0.7) {
                    return {
                        word: cleanWord,
                        entity_group: 'NOUN',
                        start: text.indexOf(word),
                        end: text.indexOf(word) + word.length
                    };
                }
                return {
                    word: cleanWord,
                    entity_group: Math.random() > 0.5 ? 'VERB' : 'ADJ',
                    start: text.indexOf(word),
                    end: text.indexOf(word) + word.length
                };
            }).filter(token => token.entity_group === 'NOUN');
        }

        function summarizeNouns(tokens, text) {
            const nounTags = new Set(['NOUN', 'PROPN']);
            const counts = new Map();
            let total = 0;
            tokens.forEach(token => {
                const group = token.entity_group || token.entity || token.tag;
                if (!group || !nounTags.has(group.toUpperCase())) {
                    return;
                }
                const surface = extractSurface(text, token);
                if (!surface) {
                    return;
                }
                total += 1;
                const key = surface.toLowerCase();
                if (counts.has(key)) {
                    counts.get(key).count += 1;
                } else {
                    counts.set(key, { word: surface, count: 1 });
                }
            });
            return { total, breakdown: Array.from(counts.values()).sort((a, b) => b.count - a.count || a.word.localeCompare(b.word)) };
        }

        function extractSurface(text, token) {
            if (typeof token.start === 'number' && typeof token.end === 'number') {
                const value = text.slice(token.start, token.end).trim();
                if (value) {
                    return value;
                }
            }
            if (token.word) {
                return token.word.replace(/^##/, '').replace(/^Ġ/, '').trim();
            }
            return '';
        }

        function updateNounResult(iconClass, message, spinning) {
            nounResult.innerHTML = '';
            const icon = document.createElement('i');
            icon.className = `fas ${iconClass} icon`;
            if (spinning) {
                icon.classList.add('fa-spin');
            }
            const span = document.createElement('span');
            span.textContent = message;
            nounResult.append(icon, span);
        }
    </script>
</body>
</html>
